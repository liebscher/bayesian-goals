<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bayesian Reading Goals</title>

    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@500&family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">

    <!-- import handlebars for simple templating capabilities -->
    <script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
  </head>
  <body>
    <div class="main-container">
      <h1 class="heading">Reading Goals</h1>
      <p>Step 1: When will your goal start and end?</p>
      <div class="dates-container">
        <div>
          <p><label for="start-date-field">Start Date</label></p>
          <input type="date" name="start-date-field" value="">
        </div>
        <div>
          <p><label for="end-date-field">End Date</label></p>
          <input type="date" name="end-date-field" value="">
        </div>
      </div>
      <br>
      <p>Step 2: Over that period, what's your goal?</p>
      <div class="goal-container">
        <label for="goal-field">Goal</label>
        <input type="number" name="goal-field" value="">
        <select class="" name="goal-unit-field">
          <option value="mpd">minutes per day</option>
          <option value="ppd">pages per day</option>
          <option value="th">total hours</option>
          <option value="tp">total pages</option>
        </select>
      </div>
      <br>
      <p>Step 3: Fill out some of your reading history to personalize your goal:</p>
      <div class="data-field-container">
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Minutes</th>
                <th>Pages</th>
              </tr>
            </thead>
            <tbody id="data-field-body">
              <tr>
                <td><input type="date" name="data-field" value=""></td>
                <td contenteditable="true"></td>
                <td contenteditable="true"></td>
              </tr>
              <tr>
                <td><input type="date" name="data-field" value=""></td>
                <td contenteditable="true"></td>
                <td contenteditable="true"></td>
              </tr>
            </tbody>
          </table>
          <div id="add-row-container">
            <span>Add Row</span>
          </div>
      </div>

      <div class="outcome-container">
        <h4>The probability you meet your goal is:</h4>
        <h3 id="outcome-probability"></h3>
        <div class="">
          <p id="outcome-plan"></p>
          <p id="outcome-history"></p>
        </div>
        <br>
        <p>What does the underlying probability distribution look like?</p>
        <div id="plot-container"></div>
        <p>Enter data above to update your personal distribution from the baseline distribution</p>
      </div>
      <footer>
        <p>This website is unlike most others and does not collect your data to profit.</p>
        <p>Created by <a href="https://liebscher.github.io/">Alex Liebscher</a></p>
      </footer>
    </div>
  </body>
  <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
  <script src="https://code.highcharts.com/highcharts.src.js"></script>
  <script src="bayesian.js"></script>
  <script type="text/javascript">

    const MS_IN_DAY = 1000 * 60 * 60 * 24
    const UNITS = {
      "hours": "hours",
      "pages": "pages"
    }
    const SCALE = {
      "perday": "per day",
      "total": "total"
    }

    // templates:
    var probability_t = Handlebars.compile("{{prob}}%");
    var plan_t = Handlebars.compile("To meet your goal over your {{days}} day period, you'll have to read {{pace}} {{unit}}");
    var history_t = Handlebars.compile("Historically, you read on average {{hoursAverage}} hours per day and {{pagesAverage}} pages per day");

    // specify the unit of the goal: will be pages or hours (or something else)
    var unit = UNITS.hours
    var scale = SCALE.perday

    var startDate = null
    var endDate = null
    var days = null // the total number of the days in the goal period
    var goal = null // the numerical goal, unitless
    var goalPace = null

    // intialize the reading history data structure with one array for hours, another for pages
    var readingHistory = [[], []]
    var paceHistory = {[UNITS.hours]: [], [UNITS.pages]: []}

    // set default values for the outcomes
    document.getElementById("outcome-probability").innerText = probability_t({prob: 0})
    document.getElementById("outcome-plan").innerText = plan_t({days: "NA", pace: "NA", unit: "hours per day"})
    document.getElementById("outcome-history").innerText = history_t({hoursAverage: "NA", pagesAverage: "NA"})

    // grab the DOM elements for parameters
    var startDateField = document.getElementsByName("start-date-field")[0]
    var endDateField = document.getElementsByName("end-date-field")[0]
    var goalField = document.getElementsByName("goal-field")[0]
    var goalUnitField = document.getElementsByName("goal-unit-field")[0]

    var dataFieldBody = document.getElementById("data-field-body")

    // set up the chart and prior curve
    let xWidth = {[UNITS.hours]: 2, [UNITS.pages]: 30}
    let xvalues = max => [...Array(200).keys()].map(x => max * x/200)

    let priorCurves = _unit => xvalues(xWidth[_unit]).map(x => ({ x, y: marginal_prior_density(x, _unit)}))

    let posteriorCurve = (params) => (xvalues(xWidth[unit]).map(x => (
      {
        x, y: marginal_posterior_density(x, params)
      }
    )))

    let flatCurve = xvalues(xWidth[unit]).map(x => ({ x, y: 0 }))

    var chart = Highcharts.chart('plot-container', {
        chart: { type: 'area' },
        title: { text: '' },
        tooltip: { enabled: false },
        series: [
          {
            data: priorCurves(unit),
            opacity: 0.4,
            name: "Baseline",
            color: '#BDBDBD',
            marker: { enabled: false }
          },
          {
            data: flatCurve,
            opacity: 0.6,
            name: "Personalized",
            color: '#2196F3',
            marker: { enabled: false }
          }
        ],
        xAxis: { plotLines: [], title: {text: 'hours per day'} },
        yAxis: {
          labels: { enabled: false },
          gridLineWidth: 0,
          title: ''
        }
    });

    // update chart posterior plot
    var redrawPosterior = (parameters) => {
      chart.series[1].update({
        data: posteriorCurve(parameters)
      })
    }

    // update chart prior plot
    var redrawPrior = () => {
      chart.series[0].update({
        data: priorCurves(unit)
      })
    }

    // update the start date of the goal
    var updateStartDate = (date) => {
      startDate = date;
    }

    // update the end date of the goal
    var updateEndDate = (date) => {
      endDate = date;
    }

    // update the numerical goal, regardless of units or scale
    var updateGoal = (_goal) => {
      goal = _goal;
    }

    // update the unit and scale structures
    var updateGoalUnit = (selector) => {
      switch (selector) {
        case "mpd":
          unit = UNITS.hours
          scale = SCALE.perday
          break;
        case "th":
          unit = UNITS.hours
          scale = SCALE.total
          break;
        case "ppd":
          unit = UNITS.pages
          scale = SCALE.perday
          break;
        case "tp":
          unit = UNITS.pages
          scale = SCALE.total
          break;
      }
    }

    // update the number of days in the period
    var updateDays = () => {
      if (startDate && endDate) {
        days = (endDate - startDate) / MS_IN_DAY
      }
    }

    // update our reading history data structure with new info
    var updateHistoryFromCellChange = (row, column, target) => {
      // depending on the column, update the history
      switch (column) {
        case 0:
          readingHistory[row][0] = new Date(target.value)
          break;
        case 1:
          readingHistory[row][1] = target.innerText / 60.0
          break;
        case 2:
          readingHistory[row][2] = target.innerText * 1.0
          break;
      }
    }

    // update our pace history using new data from the user
    var updatePaceHistory = () => {
      // for each day of the history, update its value
      readingHistory.forEach((row, ix) => {
        // only if there's a date will we update the history
        if (row[0]) {
          if (row[1] && row[1] > 0) {
            paceHistory[UNITS.hours][ix] = row[1]
          } else {
            paceHistory[UNITS.hours][ix] = undefined
          }

          if (row[2] && row[2] > 0) {
            paceHistory[UNITS.pages][ix] = row[2]
          } else {
            paceHistory[UNITS.pages][ix] = undefined
          }
        }
      })
    }

    // separate concerns and refresh plan outcome
    var refreshPlanOutcome = () => {
      let _pace = "NA";
      let _days = "NA"
      let _units = unit + " per day"

      // if the dates have been set, display the # of days
      if (days) {
        _days = days
      }

      // if both the goal and the days are set, display the pace
      if (goal && days) {
        // figure out how to scale the pace
        if (scale == SCALE.total) _pace = goal / days
        else if (unit == UNITS.hours) _pace = goal / 60
        else _pace = goal * 1.0

        // we shouldn't recommend more than 24 hours of reading per day
        if (unit == UNITS.hours && _pace >= 24) {
          _pace = "NA"
        } else {
          // if all is good, refresh the prob of meeting our goal
          goalPace = _pace
          refreshProbability()

          // update chart goal line
          if (chart.xAxis[0].options.plotLines.length == 0) {
            chart.xAxis[0].addPlotLine({
                value: goalPace,
                width: 2,
                color: '#333',
                zIndex: 100
            })
          } else {
            // if the goal line is already on the chart, just update the intercept
            chart.xAxis[0].options.plotLines[0].value = goalPace
          }
          chart.xAxis[0].update()

          _pace = _pace.toFixed(1) // for pretty printing
        }
      }

      document.getElementById("outcome-plan").innerText = plan_t({days: _days, pace: _pace, unit: _units})
    }

    // refresh the probability statement
    var refreshProbability = () => {

      // calculate the posterior parameters using some data
      parameters = marginal_posterior_parameters(paceHistory[unit].filter(Boolean), unit)

      // calculate the t-stat quantile
      let q = (goalPace - parameters.mean) / Math.pow((parameters.variance / parameters.k) / parameters.df, 0.5)

      // console.log([parameters, goalPace, q])

      // calculate the area under the t-dist left of the quantile
      let p = 1 - jStat.studentt.cdf(q, parameters.df)
      // update the outcome text
      if (goal && days) {
          document.getElementById("outcome-probability").innerText = probability_t({prob: p.toFixed(2) * 100})
      }

      return parameters
    }

    // refresh the history stats at the bottom of the page
    var refreshHistoryStats = (_history) => {
      let hHours = _history.map(r => r[1]).filter(Boolean)
      let hPages = _history.map(r => r[2]).filter(Boolean)

      let hAverages = {
        hoursAverage: hHours.length ?
          (hHours.reduce((a,b) => a + b) / hHours.length).toFixed(1) :
          "NA",
        pagesAverage: hPages.length ?
          (hPages.reduce((a,b) => a + b) / hPages.length).toFixed(1) :
          "NA",
      }

      document.getElementById("outcome-history").innerText = history_t(hAverages)
    }

    // event listeners
    startDateField.addEventListener('change', (event) => {
      updateStartDate(new Date(event.target.value))
      updateDays()
      refreshPlanOutcome()
    });

    endDateField.addEventListener('change', (event) => {
      updateEndDate(new Date(event.target.value))
      updateDays()
      refreshPlanOutcome()
    });

    goalField.addEventListener('change', (event) => {
      updateGoal(event.target.value)
      refreshPlanOutcome()
    });

    goalUnitField.addEventListener('change', (event) => {
      updateGoalUnit(event.target.value)
      refreshPlanOutcome()
      redrawPrior()
      // use the calculated parameters to draw posterior curve
      redrawPosterior(refreshProbability())
      // change the chart units
      chart.xAxis[0].update({title: {text: unit + " per day"}})
    });

    // table event listeners
    var setAllCellEventHandlers = () => {
      // we select all cells in the table and update the reading history structure
      let tablecells = dataFieldBody.querySelectorAll('td')
      tablecells.forEach((elm, ix) => {
        // figure out which row and column we're moving away from
        let column = ix % 3;
        let row = Math.floor(ix / 3)

        let cellElement = elm
        if (column == 0) {
          cellElement = elm.children[0]
        }

        // need to set the inner array to access it
        if (!readingHistory[row]) readingHistory[row] = []

        // when we move away from a cell, update our history
        cellElement.addEventListener('blur', (event) => {
          updateHistoryFromCellChange(row, column, event.target)
          updatePaceHistory()
          refreshHistoryStats(readingHistory)

          // use the newly calculated parameters to draw posterior curve
          redrawPosterior(refreshProbability())
        })
      })
    }

    setAllCellEventHandlers()

    // small static function to create empty table rows
    var createEmptyRow = () => {

      // build up a virtual DOM element
      let fragment = new DocumentFragment()
      let tr = document.createElement("tr")
      let col1 = document.createElement("td")
      let col2 = document.createElement("td")
      let col3 = document.createElement("td")
      let calendar = document.createElement("input")
      calendar.setAttribute("type", "date")

      col2.setAttribute("contenteditable", "true")
      col3.setAttribute("contenteditable", "true")

      col1.appendChild(calendar)

      tr.appendChild(col1)
      tr.appendChild(col2)
      tr.appendChild(col3)

      fragment.appendChild(tr)

      return fragment
    }

    // create a button to add new rows to the table
    document.querySelector("#add-row-container span").addEventListener('click', event => {

      let body = document.querySelector('#data-field-body')

      // add the new row onto the table body
      body.appendChild(createEmptyRow())

      // refresh the cell event handlers
      setAllCellEventHandlers()
    })

  </script>
</html>

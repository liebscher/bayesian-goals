<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bayesian Reading Goals</title>
    <link rel="stylesheet" href="style.css">

    <!-- import handlebars for simple templating capabilities -->
    <script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
  </head>
  <body>
    <div class="main-container">
      <div class="dates-container">
        <div class="">
          <label for="start-date-field">Start Date</label>
          <input type="date" name="start-date-field" value="">
        </div>
        <div class="">
          <label for="end-date-field">End Date</label>
          <input type="date" name="end-date-field" value="">
        </div>
      </div>

      <div class="goal-container">
        <label for="goal-field">Goal</label>
        <input type="number" name="goal-field" value="">
        <select class="" name="goal-unit-field">
          <option value="mpd">minutes per day</option>
          <option value="ppd">pages per day</option>
          <option value="th">total hours</option>
          <option value="tp">total pages</option>
        </select>
      </div>

      <div class="data-field-container">
          <!-- <textarea name="data-field" rows="8" cols="80"></textarea> -->
          <p>Fill out some of your reading history to personalize your goal:</p>
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Minutes</th>
                <th>Pages</th>
              </tr>
            </thead>
            <tbody id="data-field-body">
              <tr>
                <td><input type="date" name="data-field" value=""></td>
                <td contenteditable="true"></td>
                <td contenteditable="true"></td>
              </tr>
              <tr>
                <td><input type="date" name="data-field" value=""></td>
                <td contenteditable="true"></td>
                <td contenteditable="true"></td>
              </tr>
            </tbody>
          </table>
          <div id="add-row-container">
            <span>Add Row</span>
          </div>
      </div>

      <div class="outcome-container">
        <h4>The probability you meet your goal is:</h4>
        <h3 id="outcome-probability"></h3>
        <div class="">
          <p id="outcome-plan"></p>
          <p id="outcome-history"></p>
        </div>
        <div class="plot-container">
          Distribution plot here
        </div>
      </div>
    </div>
  </body>
  <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
  <script src="bayesian.js"></script>
  <script type="text/javascript">

    const MS_IN_DAY = 1000 * 60 * 60 * 24
    const UNITS = {
      "hours": "hours",
      "pages": "pages"
    }
    const SCALE = {
      "perday": "per day",
      "total": "total"
    }

    // templates:
    var probability_t = Handlebars.compile("{{prob}}%");
    var plan_t = Handlebars.compile("Over your {{days}} day period, you'd have to read {{pace}} {{unit}}");
    var history_t = Handlebars.compile("Historically, you read on average {{average}} {{unit}}");

    // specify the unit of the goal: will be pages or hours (or something else)
    var unit = UNITS.hours
    var scale = SCALE.perday

    var startDate = null
    var endDate = null
    var days = null // the total number of the days in the goal period
    var goal = null // the numerical goal, unitless
    var goalPace = null

    var readingHistory = [[], []]
    var paceHistory = {[UNITS.hours]: [], [UNITS.pages]: []}

    // set default values for the outcomes
    document.getElementById("outcome-probability").innerText = probability_t({prob: 0})
    document.getElementById("outcome-plan").innerText = plan_t({days: "NA", pace: "NA", unit: "hours per day"})
    document.getElementById("outcome-history").innerText = history_t({average: "NA", unit: "hours per day"})

    // grab the DOM elements for parameters
    var startDateField = document.getElementsByName("start-date-field")[0]
    var endDateField = document.getElementsByName("end-date-field")[0]
    var goalField = document.getElementsByName("goal-field")[0]
    var goalUnitField = document.getElementsByName("goal-unit-field")[0]

    var dataFieldBody = document.getElementById("data-field-body")

    // update the start date of the goal
    var updateStartDate = (date) => {
      startDate = date;
    }

    // update the end date of the goal
    var updateEndDate = (date) => {
      endDate = date;
    }

    // update the numerical goal, regardless of units or scale
    var updateGoal = (_goal) => {
      goal = _goal;
    }

    // update the unit and scale structures
    var updateGoalUnit = (selector) => {
      switch (selector) {
        case "mpd":
          unit = UNITS.hours
          scale = SCALE.perday
          break;
        case "th":
          unit = UNITS.hours
          scale = SCALE.total
          break;
        case "ppd":
          unit = UNITS.pages
          scale = SCALE.perday
          break;
        case "tp":
          unit = UNITS.pages
          scale = SCALE.total
          break;
      }
    }

    // update the number of days in the period
    var updateDays = () => {
      if (startDate && endDate) {
        days = (endDate - startDate) / MS_IN_DAY
      }
    }

    // update our reading history data structure with new info
    var updateHistoryFromCellChange = (row, column, target) => {
      // depending on the column, update the history
      switch (column) {
        case 0:
          readingHistory[row][0] = target.value
          break;
        case 1:
          readingHistory[row][1] = target.innerText / 60.0
          break;
        case 2:
          readingHistory[row][2] = target.innerText * 1.0
          break;
      }
    }

    // update our pace history using new data from the user
    var updatePaceHistory = () => {
      // for each day of the history, update its value
      readingHistory.forEach((row, ix) => {
        // only if there's a date will we update the history
        if (row[0]) {
          if (row[1] && row[1] > 0) {
            paceHistory[UNITS.hours][ix] = row[1]
          } else {
            paceHistory[UNITS.hours][ix] = undefined
          }

          if (row[2] && row[2] > 0) {
            paceHistory[UNITS.pages][ix] = row[2]
          } else {
            paceHistory[UNITS.pages][ix] = undefined
          }
        }
      })
    }

    // separate concerns and refresh plan outcome
    var refreshPlanOutcome = () => {
      let _pace = "NA";
      let _days = "NA"
      let _units = unit + " per day"

      // if the dates have been set, display the # of days
      if (days) {
        _days = days
      }

      // if both the goal and the days are set, display the pace
      if (goal && days) {
        // figure out how to scale the pace
        if (scale == SCALE.total) _pace = goal / days
        else if (unit == UNITS.hours) _pace = goal / 60
        else _pace = goal * 1.0

        // we shouldn't recommend more than 24 hours of reading per day
        if (unit == UNITS.hours && _pace >= 24) {
          _pace = "NA"
        } else {
          // if all is good, refresh the prob of meeting our goal
          goalPace = _pace
          refreshProbability()
          _pace = _pace.toFixed(1) // for pretty printing
        }
      }

      document.getElementById("outcome-plan").innerText = plan_t({days: _days, pace: _pace, unit: _units})
    }

    // refresh the probability statement
    var refreshProbability = () => {

      // calculate the posterior parameters using some data
      // NOTE: fake data here for the time being
      parameters = marginal_posterior_parameters(paceHistory[unit].filter(Boolean), unit)

      // calculate the t-stat quantile
      let q = (goalPace - parameters.mean) / Math.pow((parameters.variance / parameters.k) / parameters.df, 0.5)

      // console.log([parameters, goalPace, q])

      // calculate the area under the t-dist left of the quantile
      let p = 1 - jStat.studentt.cdf(q, parameters.df)
      // update the outcome text
      if (goal && days) {
          document.getElementById("outcome-probability").innerText = probability_t({prob: p.toFixed(2) * 100})
      }
    }

    // event listeners
    startDateField.addEventListener('change', (event) => {
      updateStartDate(new Date(event.target.value))
      updateDays()
      refreshPlanOutcome()
    });

    endDateField.addEventListener('change', (event) => {
      updateEndDate(new Date(event.target.value))
      updateDays()
      refreshPlanOutcome()
    });

    goalField.addEventListener('change', (event) => {
      updateGoal(event.target.value)
      refreshPlanOutcome()
    });

    goalUnitField.addEventListener('change', (event) => {
      updateGoalUnit(event.target.value)
      refreshPlanOutcome()
    });

    // table event listeners
    var setAllCellEventHandlers = () => {
      // we select all cells in the table and update the reading history structure
      let tablecells = dataFieldBody.querySelectorAll('td')
      tablecells.forEach((elm, ix) => {
        // figure out which row and column we're moving away from
        let column = ix % 3;
        let row = Math.floor(ix / 3)

        let cellElement = elm
        if (column == 0) {
          cellElement = elm.children[0]
        }

        if (!readingHistory[row]) readingHistory[row] = []

        // when we move away from a cell, update our history
        cellElement.addEventListener('blur', (event) => {
          updateHistoryFromCellChange(row, column, event.target)
          updatePaceHistory()
          refreshProbability()
        })
      })
    }

    setAllCellEventHandlers()

    // create a button to add new rows to the table
    document.querySelector("#add-row-container span").addEventListener('click', event => {

      // build up a virtual DOM element
      let fragment = new DocumentFragment()
      let tr = document.createElement("tr")
      let col1 = document.createElement("td")
      let col2 = document.createElement("td")
      let col3 = document.createElement("td")
      let calendar = document.createElement("input")
      calendar.setAttribute("type", "date")

      col2.setAttribute("contenteditable", "true")
      col3.setAttribute("contenteditable", "true")

      col1.appendChild(calendar)

      tr.appendChild(col1)
      tr.appendChild(col2)
      tr.appendChild(col3)

      fragment.appendChild(tr)

      let body = document.querySelector('#data-field-body')

      // add the new row onto the table body
      body.appendChild(fragment)

      // refresh the cell event handlers
      setAllCellEventHandlers()
    })

  </script>
</html>

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bayesian Reading Goals</title>

    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@500&family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">

    <!-- import handlebars for simple templating capabilities -->
    <script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
  </head>
  <body>
    <div class="main-container">
      <h1 class="heading">Reading Goals</h1>
      <img id="book" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QA/wD/AP+gvaeTAAAErklEQVR4nO2ab2hVZRjAf889Z/5htmEwobH6UEgrqa1ZUpTsU34ITUakRK1guCmIQn/I/qCGNSILhepDS3O1GYiTTBS0FahlCWpmykgx+rK5L1YjbJZ273n6cO9xd3d7zz2ecyYX9v7gcHnf9znP877veZ7nvvA+YLFYLBaLxTJJkbgKalbqYwgdQE3B0ADQNvCh7I9rYyJx4ypwoEN0zOIhuyEdwG1xbUwkoT2g5nmdPvUKG1GWAlWF403PjG7v3j5GxRDwm8AXuGz59QO5mD94xwqdRYpWlCbgdmBm2LnlcRHYcWUaawY2yz9hXgjtATMu867CStN4ZaZAsTdGZCYwF5jLVV6sXaHPnf1I9gHULtdFqnxGJtKi86kCVjmXAVgd5oXQG+AoSwA8ofGXDvnW75/TpgpQmS5QrNnfvo9FAO5t1vLMdOYhvICyEGXPXct1kaOIKl8CKWCvpNiUGub46W4ZDjs3n3tatdETDgFLSXoDXC/r9j9vHVl8rh8o7gG5BR0EDtYv09cV3gL8QEmp8trpT+TtsPMZjzNb5HDdMgWYFfYd4wbMeVKnTK3gTZRm4BbGujQAjmEDHIM8wKmt0t7Qog8CCwFQ9p7sjLf4QrsNLarAoED3v5dY19cjV8eTN25A+U1swOPlYgZ9V68whEDAe5vJbUBK2VTMTlgK7FYDa2aUo8Cr48mnjIoyNLseOPDwsU4R1xs3seH3V2ZGPyZ5nzLhuC8zbZgToVYXAl/nsU6RKRnmux44yrMmefMGKNWuwtFO+SHXHver+v2V6dGPSd7n+21yyZc51CN/X88ig8i3e6RLjuTa1UZ500BhDJti2vEYAGpadxf0Awj9QZMNyhNRCTtvH7MHFLiwyaXLlDbXo98fz3v6U2nagowXC5MohJ33tXHjgAa3fXo/l/1EPO4WS5RJ6CyajI0DXnA7CW6EzmI2YntAHEraA643mUShFJKgDQHjwGQPgUnvATYH2BAIbidBSYfApPcAmwNsCAS3k6CkQ2DSe4DNATYEgttJUNIhMOk9wOYAGwLB7SQo6RAw7eTWBzTqtIeB88C+VJr3W36Si/k2tt2nVZ7LarLXZbOB8khWSvgcUA7UA/WkWNXZoC3+ZD+9X59QZZvjURHbSgGJnwOaT0qkuqKdD+nNV/5jLh4vAQuAHnwbyk4gJfBVRnnPTfPj02dkKIqd7obRHloy54AlR+VP4GtFv9lRTzujb2tTCu1PnWKtILEyw0QmwQGgpqcucg4AYBcMucoJsjVDfknMEDBvVx1/9KDxymQUhJE7ycTOAa5Hm2arvm6NNcHsoh8N0ReVfmTkTjKxc0DTmeh3gPnsuVOrxaUZ2ABMyXVfVVhLmu2Lz8lgXBv5FAuBoPqAQVdh/xx9JMkJLT4ng4/3yTtlsN6/y3dh3eI+2Zj04g/crfNz+i+YZIJCoEvgFeC73tpkTywLzoo4aboQsnVBSjdAb228/DIG79oX7jKJGDfgL4f1VRnQbHmJscIiKguyX3vUX+oEnAwvoHT9XsYbJoHYtcLXw+HZ2s/YmuJC+hvPyw0rrzXmgInA8YzVJNeqSsq84KoSi8VisVgsFktC/A9JZPwnrP7ePQAAAABJRU5ErkJggg=="/>
      <p class="wide-text">How can you set an achievable reading goal? This site approximates the probability that you'll meet your goal, based on only a small sample of how you already read. Give it a try!</p>
      <br>
      <p>Step 1: When will your goal start and end?</p>
      <div class="dates-container">
        <div>
          <p><label for="start-date-field">Start Date</label></p>
          <input type="date" name="start-date-field" value="">
        </div>
        <div>
          <p><label for="end-date-field">End Date</label></p>
          <input type="date" name="end-date-field" value="">
        </div>
      </div>
      <br>
      <p>Step 2: Over that period, what's your goal?</p>
      <div class="goal-container">
        <label for="goal-field">Goal</label>
        <input type="number" name="goal-field" value="">
        <select class="" name="goal-unit-field">
          <option value="mpd">minutes per day</option>
          <option value="ppd">pages per day</option>
          <option value="th">total hours</option>
          <option value="tp">total pages</option>
        </select>
      </div>
      <br>
      <p>Step 3: Give a sample of how much you read per day:</p>
      <p class="wide-text" style="color: #bbb;">Feel free to enter as much or as little as you'd like. This works best if you have kept track of your reading for a few days and know exactly how much you've read. Use the Minutes or Pages column according to your goal.</p>
      <div class="data-field-container">
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>Minutes</th>
                <th>Pages</th>
              </tr>
            </thead>
            <tbody id="data-field-body">
              <tr>
                <td><input type="date" name="data-field" value=""></td>
                <td contenteditable="true"></td>
                <td contenteditable="true"></td>
              </tr>
              <tr>
                <td><input type="date" name="data-field" value=""></td>
                <td contenteditable="true"></td>
                <td contenteditable="true"></td>
              </tr>
            </tbody>
          </table>
          <div id="add-row-container">
            <span>Add Row</span>
          </div>
      </div>

      <div class="outcome-container">
        <h4>The probability you meet your goal is:</h4>
        <h3 id="outcome-probability"></h3>
        <div class="">
          <p id="outcome-plan"></p>
          <p id="outcome-history"></p>
        </div>
        <br>
        <p>Here are the underlying probability distributions:</p>
        <div id="plot-container"></div>
        <p>Enter data above in either column to update your personal distribution from the baseline distribution</p>
      </div>
      <footer>
        <p>This website is unlike most others and does not collect your data to profit.</p>
        <p>Created by <a href="https://liebscher.github.io/">Alex Liebscher</a></p>
        <p>Open Book icon by <a href="https://icons8.com/icon/52991/open-book">Icons8</a></p>
      </footer>
    </div>
  </body>
  <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
  <script src="https://code.highcharts.com/highcharts.src.js"></script>
  <script src="bayesian.js"></script>
  <script type="text/javascript">

    const MS_IN_DAY = 1000 * 60 * 60 * 24
    const UNITS = {
      "hours": "hours",
      "pages": "pages"
    }
    const SCALE = {
      "perday": "per day",
      "total": "total"
    }

    // templates:
    var probability_t = Handlebars.compile("{{prob}}%");
    var plan_t = Handlebars.compile("Your goal is to read {{pace}} {{unit}} over {{days}} days");
    var history_t = Handlebars.compile("Historically, you've read on average {{hoursAverage}} hours per day and {{pagesAverage}} pages per day");

    // specify the unit of the goal: will be pages or hours (or something else)
    var unit = UNITS.hours
    var scale = SCALE.perday

    var startDate = null
    var endDate = null
    var days = null // the total number of the days in the goal period
    var goal = null // the numerical goal, unitless
    var goalPace = null

    // intialize the reading history data structure with one array for hours, another for pages
    var readingHistory = [[], []]
    var paceHistory = {[UNITS.hours]: [], [UNITS.pages]: []}

    // determine if the goal is fully specified, with both dates and a goal
    var isGoalFullySet = () => goal && days

    // set default values for the outcomes
    document.getElementById("outcome-probability").innerText = probability_t({prob: 0})
    document.getElementById("outcome-plan").innerText = plan_t({days: "0", pace: "0", unit: "hours per day"})
    document.getElementById("outcome-history").innerText = history_t({hoursAverage: "0", pagesAverage: "0"})

    // grab the DOM elements for parameters
    var startDateField = document.getElementsByName("start-date-field")[0]
    var endDateField = document.getElementsByName("end-date-field")[0]
    var goalField = document.getElementsByName("goal-field")[0]
    var goalUnitField = document.getElementsByName("goal-unit-field")[0]

    var dataFieldBody = document.getElementById("data-field-body")

    // set up the chart and prior curve
    let xWidth = {[UNITS.hours]: 2, [UNITS.pages]: 30}
    let xvalues = max => [...Array(200).keys()].map(x => max * x/200)

    let priorCurves = _unit => xvalues(xWidth[_unit]).map(x => ({ x, y: marginal_prior_density(x, _unit)}))

    let posteriorCurve = (params) => (xvalues(xWidth[unit]).map(x => (
      {
        x, y: marginal_posterior_density(x, params)
      }
    )))

    let flatCurve = () => xvalues(xWidth[unit]).map(x => ({ x, y: 0 }))

    var chart = Highcharts.chart('plot-container', {
        chart: { type: 'area' },
        title: { text: '' },
        tooltip: { enabled: false },
        series: [
          {
            data: priorCurves(unit),
            opacity: 0.4,
            name: "Baseline",
            color: '#BDBDBD',
            marker: { enabled: false }
          },
          {
            data: flatCurve(),
            opacity: 0.6,
            name: "Personalized",
            color: '#2196F3',
            marker: { enabled: false }
          }
        ],
        // TODO: color area only in the upper tail
        // plotOptions: {
        //   area: {
        //     zoneAxis: 'x',
        //     zones: [
        //       {fillColor: 'white', value: 0},
        //       {value: xWidth[unit]}
        //     ]
        //   },
        // },
        xAxis: { plotLines: [], title: {text: 'hours per day'} },
        yAxis: {
          labels: { enabled: false },
          gridLineWidth: 0,
          title: ''
        }
    });

    // update chart posterior plot
    var redrawPosterior = () => {
      let parameters = marginal_posterior_parameters(paceHistory[unit].filter(Boolean), unit)
      chart.series[1].update({
        data: posteriorCurve(parameters)
      })
    }

    // when a user removes all data, reset the posterior curve
    var drawFlatPosterior = () => {
      chart.series[1].update({
        data: flatCurve()
      })
    }

    // update chart prior plot
    var redrawPrior = () => {
      chart.series[0].update({
        data: priorCurves(unit)
      })
    }

    // update the start date of the goal
    var updateStartDate = (date) => {
      startDate = date;
    }

    // update the end date of the goal
    var updateEndDate = (date) => {
      endDate = date;
    }

    // update the numerical goal, regardless of units or scale
    var updateGoal = (_goal) => {
      goal = _goal;
    }

    // update the unit and scale structures
    var updateGoalUnit = (selector) => {
      switch (selector) {
        case "mpd":
          unit = UNITS.hours
          scale = SCALE.perday
          break;
        case "th":
          unit = UNITS.hours
          scale = SCALE.total
          break;
        case "ppd":
          unit = UNITS.pages
          scale = SCALE.perday
          break;
        case "tp":
          unit = UNITS.pages
          scale = SCALE.total
          break;
      }
    }

    // update the number of days in the period if both dates are filled out
    var updateDays = () => {
      if (startDate && endDate) {
        days = (endDate - startDate) / MS_IN_DAY
      }
    }

    // update our reading history data structure with new info
    var updateHistoryFromCellChange = (row, column, target) => {
      // depending on the column, update the history
      switch (column) {
        case 0:
          readingHistory[row][0] = new Date(target.value)
          break;
        case 1:
          readingHistory[row][1] = target.innerText / 60.0
          break;
        case 2:
          readingHistory[row][2] = target.innerText * 1.0
          break;
      }
    }

    // update our pace history using new data from the user
    var updatePaceHistory = () => {
      // for each day of the history, update its value
      readingHistory.forEach((row, ix) => {
        // only if there's a date will we update the history
        if (row[0]) {
          if (row[1] && row[1] > 0) {
            paceHistory[UNITS.hours][ix] = row[1]
          } else {
            paceHistory[UNITS.hours][ix] = undefined
          }

          if (row[2] && row[2] > 0) {
            paceHistory[UNITS.pages][ix] = row[2]
          } else {
            paceHistory[UNITS.pages][ix] = undefined
          }
        }
      })
    }

    // Update plotline and area highlighting on every new goal
    var updateGoalVisualization = (_goalPace) => {
      // update chart goal line
      if (chart.xAxis[0].options.plotLines.length == 0) {
        chart.xAxis[0].addPlotLine({
            value: _goalPace,
            width: 2,
            color: '#333',
            zIndex: 100
        })
      } else {
        // if the goal line is already on the chart, just update the intercept
        chart.xAxis[0].options.plotLines[0].value = _goalPace
        chart.xAxis[0].update()
      }

      // only give area to the right of the goal line
      // TODO: shade only the upper tail region, right of the goal line
      //       currently fails to animate smoothly
      // chart.series[0].update({
      //   zoneAxis: 'x',
      //   zones: [{ fillColor: 'white', value: _goalPace }, { value: xWidth[unit]}]
      // })

      // chart.series[1].update({
      //   zoneAxis: 'x',
      //   zones: [{ fillColor: 'white', value: _goalPace }, { value: xWidth[unit]}]
      // })

    }

    // separate concerns and refresh plan outcome
    var refreshPlanOutcome = () => {
      let _pace = "0";
      let _days = "0"
      let _units = unit + " per day"

      // if the dates have been set, display the # of days
      if (days) {
        _days = days
      }

      if (isGoalFullySet()) {
        // figure out how to scale the pace
        if (scale == SCALE.total) _pace = goal / days
        else if (unit == UNITS.hours) _pace = goal / 60
        else _pace = goal * 1.0

        // we shouldn't recommend more than 24 hours of reading per day
        if (unit == UNITS.hours && _pace >= 24) {
          _pace = "NA"
        } else {
          goalPace = _pace
          _pace = _pace.toFixed(2) // for pretty printing
        }
      }

      document.getElementById("outcome-plan").innerText = plan_t({days: _days, pace: _pace, unit: _units})
    }

    var calculatePosteriorProbability = () => {
      // calculate the posterior parameters using some data
      parameters = marginal_posterior_parameters(paceHistory[unit].filter(Boolean), unit)

      // calculate the t-stat quantile
      let q = (goalPace - parameters.mean) / Math.pow((parameters.variance / parameters.k) / parameters.df, 0.5)

      // calculate the area under the t-dist right of the quantile (upper tail)
      return 1 - jStat.studentt.cdf(q, parameters.df)
    }

    // refresh the probability statement
    var refreshProbabilityStatement = () => {
      if (isGoalFullySet()) {
          let prettyPosteriorProbability = Number.parseInt(calculatePosteriorProbability() * 100)

          document.getElementById("outcome-probability").innerText = probability_t({prob: prettyPosteriorProbability})
      }
    }

    // refresh the history stats at the bottom of the page
    var refreshHistoryStats = (_history) => {
      // keep only non-empty values of each inner array
      let allHoursRead = _history.map(r => r[1]).filter(Boolean)
      let allPagesRead = _history.map(r => r[2]).filter(Boolean)

      let historicalReadingAverages = {
        hoursAverage: allHoursRead.length ?
          (allHoursRead.reduce((a,b) => a + b) / allHoursRead.length).toFixed(1) :
          "0",
        pagesAverage: allPagesRead.length ?
          (allPagesRead.reduce((a,b) => a + b) / allPagesRead.length).toFixed(1) :
          "0",
      }

      document.getElementById("outcome-history").innerText = history_t(historicalReadingAverages)
    }

    // determine if there is at least one row that has a complete pace (unit and date)
    var hasReadingHistoryForUnit = (_unit) => {
      for (let pace of paceHistory[_unit]) {
        if (pace > 0) return true
      }
      return false
    }

    // event listeners
    startDateField.addEventListener('change', (event) => {
      updateStartDate(new Date(event.target.value))
      updateDays()
      refreshPlanOutcome()
      refreshProbabilityStatement()
      updateGoalVisualization(goalPace)
    });

    endDateField.addEventListener('change', (event) => {
      updateEndDate(new Date(event.target.value))
      updateDays()
      refreshPlanOutcome()
      refreshProbabilityStatement()
      updateGoalVisualization(goalPace)
    });

    goalField.addEventListener('change', (event) => {
      updateGoal(event.target.value)
      refreshPlanOutcome()
      refreshProbabilityStatement()
      updateGoalVisualization(goalPace)
    });

    goalUnitField.addEventListener('change', (event) => {
      updateGoalUnit(event.target.value)
      refreshPlanOutcome()
      refreshProbabilityStatement()
      updateGoalVisualization(goalPace)

      // as the unit changes, we need to update the prior curve on chart
      redrawPrior()

      if (hasReadingHistoryForUnit(unit)) {
        redrawPosterior()
      } else {
        drawFlatPosterior()
      }

      // change the chart units
      chart.xAxis[0].update({title: {text: unit + " per day"}})
    });

    // table event listeners
    var setAllCellEventHandlers = () => {
      // we select all cells in the table and update the reading history structure
      let tablecells = dataFieldBody.querySelectorAll('td')
      tablecells.forEach((elm, ix) => {
        // figure out which row and column we're moving away from
        let column = ix % 3;
        let row = Math.floor(ix / 3)

        let cellElement = elm
        if (column == 0) {
          cellElement = elm.children[0]
        }

        // need to set the inner array to access it
        if (!readingHistory[row]) readingHistory[row] = []

        // when we move away from a cell, update our history
        cellElement.addEventListener('blur', (event) => {
          updateHistoryFromCellChange(row, column, event.target)
          updatePaceHistory()
          refreshHistoryStats(readingHistory)
          refreshProbabilityStatement()

          // use the newly calculated parameters to draw posterior curve
          if (hasReadingHistoryForUnit(unit)) {
            redrawPosterior()
          } else {
            drawFlatPosterior()
          }
        })
      })
    }

    // default on page, set event handlers for each of the six cells
    setAllCellEventHandlers()

    // small static function to create empty table rows
    var createEmptyRow = () => {

      // build up a virtual DOM element
      let fragment = new DocumentFragment()
      let tr = document.createElement("tr")
      let col1 = document.createElement("td")
      let col2 = document.createElement("td")
      let col3 = document.createElement("td")
      let calendar = document.createElement("input")
      calendar.setAttribute("type", "date")

      col2.setAttribute("contenteditable", "true")
      col3.setAttribute("contenteditable", "true")

      col1.appendChild(calendar)

      tr.appendChild(col1)
      tr.appendChild(col2)
      tr.appendChild(col3)

      fragment.appendChild(tr)

      return fragment
    }

    // create a button to add new rows to the table
    document.querySelector("#add-row-container span").addEventListener('click', event => {

      let body = document.querySelector('#data-field-body')

      // add the new row onto the table body
      body.appendChild(createEmptyRow())

      // refresh the cell event handlers
      setAllCellEventHandlers()
    })

  </script>
</html>
